---
output: github_document
---

<!-- badges: start -->
  [![Travis build status](https://travis-ci.org/curso-r/ltm.svg?branch=master)](https://travis-ci.org/curso-r/ltm)
[![AppVeyor build status](https://ci.appveyor.com/api/projects/status/github/curso-r/ltm?branch=master&svg=true)](https://ci.appveyor.com/project/curso-r/ltm)
[![CRAN status](https://www.r-pkg.org/badges/version/ltm)](https://cran.r-project.org/package=ltm)
<!-- badges: end -->

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# ltm

The goal of ltm is to fit Bayesian Latent Threshold Models using R. The model in the AR(1) form is defined by these equations:

$$\begin{aligned}
y_{it} &= \sum_{j=1}^J x_{ijt} b_{ijt} + \varepsilon_{it} \\
b_{ijt} &= \beta_{ijt} \,\mathbb I(|\beta_{ijt}| \geq d_{ij}) \\
\beta_{ij,t+1} &= \mu_{ij} + \phi_{ij}(\beta_{ijt}-\mu_{ij}) + \eta_{ijt}
\end{aligned}$$

for $i \in 1,\dots, I$, $j \in 1,\dots, J$ and $t \in 1,\dots, T$. These models can be fit separatedly for each $i$. The example below fits the model to one single series ($I=1$).

## Load packages

```{r}
library(tidyverse)
devtools::load_all()
```

## Simulated Example

```{r example, fig.height=5, fig.width=7}
set.seed(103)

d_sim <- ltm_sim(
  ni = 5, ns = 500, nk = 2, 
  alpha = 0,
  vmu = matrix(c(.5,.5), nrow = 2), 
  mPhi = diag(2) * c(.99, .99),
  mSigs = c(.1,.1),
  dsig = .15,
  vd = matrix(c(.4,.4), nrow = 2)
)

# adding zeroed beta
binder <- array(runif(500)-.5, c(5, 500, 1))
d_sim$mx <- abind::abind(d_sim$mx, binder, along = 3)
d_sim$mb <- cbind(d_sim$mb, 0)
```

```{r eval=FALSE}
result <- ltm_mcmc(d_sim$mx, d_sim$vy, burnin = 100, iter = 500)
# readr::write_rds(result, "data-raw/result.rds", compress = "xz")
```

    Iteration:     1 /   600 [  0%]  (Warmup)
    Iteration:    60 /   600 [ 10%]  (Warmup)
    Iteration:   120 /   600 [ 20%]  (Sampling)
    Iteration:   180 /   600 [ 30%]  (Sampling)
    Iteration:   240 /   600 [ 40%]  (Sampling)
    Iteration:   300 /   600 [ 50%]  (Sampling)
    Iteration:   360 /   600 [ 60%]  (Sampling)
    Iteration:   420 /   600 [ 70%]  (Sampling)
    Iteration:   480 /   600 [ 80%]  (Sampling)
    Iteration:   540 /   600 [ 90%]  (Sampling)
    Iteration:   600 /   600 [ 100%]  (Sampling)

## Results

Results after 100 burnin and 500 iterations.

```{r}
result <- read_rds("data-raw/result.rds")
```

### Summary statistics

```{r}
vars_to_analyse <- !str_detect(colnames(result), "beta\\[")
summary_table <- result[,vars_to_analyse] %>%
  as.data.frame() %>%
  tibble::rowid_to_column() %>%
  tidyr::gather(key, val, -rowid) %>%
  dplyr::group_by(key) %>%
  dplyr::summarise(
    median = median(val),
    sd = sd(val),
    q025 = quantile(val, 0.025),
    q975 = quantile(val, 0.975)
  )

knitr::kable(summary_table)
```

### MCMC Chains

```{r trace, fig.height=3, fig.width=7}
bayesplot::mcmc_trace(result, regex_pars = "mu\\[[12]") +
  theme_bw()
```

### Estimated Betas

```{r betas, fig.height=5, fig.width=7, eval=FALSE}
# check this function inside demo/ folder
plot_betas(result, 1:3, real_values = d_sim) +
  facet_wrap(~factor(p), ncol = 2) +
  theme_bw()
```

## Model details

### Sampling from $\alpha_i^{*}$

$$\bar y_i = \frac 1 T \sum_{t=1} y_{it}$$

$$\mu^{*}_{\alpha} = \frac{a^*T + \mu_{\alpha}^0 s_{\alpha}^0}{T + s_{\alpha}^0},$$

where

$$a^*_i=\frac{1}{K}\sum_{t=1}^{T}\sum_{k=1}^{K}x_{itk}\beta_{tk}$$

Generate using 

$$\boldsymbol\alpha^{*} \sim\mathcal N(\mu_{\alpha}^{*}, \sigma^{*2}),$$

where $\sigma^{*2}$ is the posterior sample of $\sigma$

### Sampling from $\boldsymbol\beta$

The difference between the paper and the code is that it checks if some of the $\boldsymbol\beta$ should be replaced by zero. Actually, it is not a difference; the appendix is just a little obscure in this passage.

First, we calculate $M_t$ and $m_t$ (depending on $t$), then we generate candidates for $\beta_t$ and their log-densities using the normal distribution.

We then recalculate $M_t$ and $m_t$, replacing some of $x_t$'s entries by zero, depending on a condition based on the threshold and the values of $\boldsymbol\beta$. Finally, we obtain the log-density of the previously calculated $m_t$ using these new parameters. This is the MH step where we draw a candidate from a (auxiliary) posterior distribution of non-threshold model. When we decide to accept the candidate, we compute the posterior distribution of the auxiliary posterior distribution and the true posterior distribution (of the threshold model). For the latter, we need to replace some of $x_t$'s entries by zero depending on a condition based on the threshold and the betas.

It's important to note that if there aren't any $\beta$ to replace by zero, then we should accept the new $\boldsymbol\beta$ with probability one, because the posterior has an analytic formula.

## LICENSE

MIT
